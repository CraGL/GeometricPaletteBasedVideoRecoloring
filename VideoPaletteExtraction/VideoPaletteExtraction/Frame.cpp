#include "Frame.h"
#include <fstream>
#include "nlopt.h"
#include <fstream>
using namespace std;

Frame::Frame() {
	m_kdtree = 0;
	m_refine_size = 0.15; 
	m_blk_id = -1;
}

Frame::Frame(string img_path, string ch_path,int fid, bool is_keyframe, double normal_t) {
	m_is_keyframe = is_keyframe;
	m_rloss = 0; 
	m_closs = 0;
	m_refine_size = 0.15; 
	m_frm_id = fid;
	m_blk_id = -1;
	m_normal_t = normal_t;

	ReadFrame(img_path);
	ReadConvexHull(ch_path);
	
	//evenly sample pixels 
	int pixel_step = (m_img.size() * 1.0) / SysParameter::SampFrmPixCnt(); 
	for (int i = 0; i < m_img.size(); i += pixel_step)  
		m_samp_pix_ids.push_back(i); 
	
	/*
	//randomly sample pixels
	m_samp_pix_ids.clear();
	m_samp_pix_ids.resize(samp_pix_cnt);

	RNG rng((unsigned)time(NULL));
	int pix_cnt = m_img.size();
	for (int i = 0; i < samp_pix_cnt; i++) {
		m_samp_pix_ids[i] =  rng.uniform(1, pix_cnt);
	}*/

	BuildKdTree();
}

void Frame::ReadFrame(string img_path) {

	Mat img = imread(img_path);
	int channels = img.channels();

	m_img.clear();
	m_img.resize(img.rows * img.cols);
	int k = 0;

	for (int nrow = 0; nrow < img.rows; nrow++) { 
		uchar* data = img.ptr<uchar>(nrow);
		for (int ncol = 0; ncol < img.cols; ncol++) {
			uchar B = data[channels * ncol];
			uchar G = data[channels * ncol + 1];
			uchar R = data[channels * ncol + 2];

			m_img[k++] = cv::Vec3d(R / 255.0, G / 255.0, B / 255.0);
		}
	}
}

void Frame::ReadConvexHull(string ch_path) {

	vector<cv::Vec3d> rgb_ch_vertices;
	vector<cv::Vec3i> rgb_ch_faces;

	ifstream in(ch_path);
	double v1, v2, v3; 
	char c;

	while (!in.eof()) {
		in >> c;
		if (c == 'v') {
			in >> v1 >> v2 >> v3;
			cv::Vec3d vert(v1, v2, v3);
			rgb_ch_vertices.push_back(vert);
		}
		else
			break;
	}
	m_cvxhull.m_vertices = rgb_ch_vertices;

	//convex hull generated by Jianchao's method maybe non convex，rebuild
	ReBuildConvexHull();

	/*
	if (rgb_ch_vertices.size() > 7) 
		m_cvxhull.SimplifyConvexHull(7);
	m_cvxhull.MergeShortEdge(0.10);
	*/

	if (rgb_ch_vertices.size() > 8)
		m_cvxhull.SimplifyConvexHull(8);
	m_cvxhull.MergeShortEdge(0.10);
	
}

void Frame::BuildKdTree() {
	
	int samp_cnt = m_samp_pix_ids.size();
	vector<cv::Vec3d> features(samp_cnt);
	for (int j = 0; j < m_samp_pix_ids.size(); j++) {
		int pixel_id = m_samp_pix_ids[j];
		cv::Vec3d rgb = m_img[pixel_id];
		features[j] = rgb;
	}

	cv::Mat source = cv::Mat(features).reshape(1);
	source.convertTo(source, CV_32F);
	m_pixel_mat = source;

	//cv::flann::KDTreeIndexParams indexParams(4);
	//m_kdtree = new cv::flann::Index(m_pixel_mat, indexParams);

	m_kdtree = new cv::flann::Index(source, flann::LinearIndexParams(), cvflann::FLANN_DIST_L2);
}

void Frame::ReBuildConvexHull() {

	//re-calculate convex hull
	RgbConvexhull new_ch3d(m_cvxhull.m_vertices);

	//indicate the vertices that lie on the convex hull
	vector<bool> flag(m_cvxhull.m_vertices.size(), false);
	for (int i = 0; i < new_ch3d.m_simplices.size(); i++) {
		cv::Vec3i simplex = new_ch3d.m_simplices[i];
		flag[simplex[0]] = flag[simplex[1]] = flag[simplex[2]] = true;
	}

	//discard the vertices inside the convex hull，re-calculate the convex hull
	vector<cv::Vec3d> new_vertices;
	for (int i = 0; i < m_cvxhull.m_vertices.size(); i++) {
		if (flag[i])
			new_vertices.push_back(m_cvxhull.m_vertices[i]);
	}
	RgbConvexhull new_cvxhull(new_vertices);
	m_cvxhull = new_cvxhull;
}

double Frame::GetReconstuctLoss() {

	double total_loss = 0;
	vector<double> distance(m_samp_pix_ids.size());

	//#pragma omp parallel for num_threads(4)
	for (int i = 0; i < m_samp_pix_ids.size(); i++) {
		int pixel_id = m_samp_pix_ids[i];
		Vec3d rgb = m_img[pixel_id];
		distance[i] = m_cvxhull.MinDistance2Point(rgb);
	}

	for (int i = 0; i < distance.size(); i++)
		total_loss += distance[i];

	total_loss /= m_samp_pix_ids.size();
	return (m_rloss = total_loss);
}

double Frame::GetCompactLoss() {

	int queryNum = 50;					//neighbor vertex number
	vector<float> queryPoint(3);		//query point
	vector<int> vecIndex(queryNum);		//neighbor vertex index
	vector<float> vecDist(queryNum);	//their distances
	cv::flann::SearchParams params(32);	//kd-tree parameters

	double total_loss = 0;
	vector<cv::Vec3d> ch_vertices = m_cvxhull.m_vertices;
	for (int j = 0; j < ch_vertices.size(); j++) {
		queryPoint[0] = (float)ch_vertices[j][0];
		queryPoint[1] = (float)ch_vertices[j][1];
		queryPoint[2] = (float)ch_vertices[j][2]; 

		m_kdtree->knnSearch(queryPoint, vecIndex, vecDist, queryNum, params);

		cv::Vec3d center(0, 0, 0);
		for (int k = 0; k < vecIndex.size(); k++) {
			int pix_id = m_samp_pix_ids[vecIndex[k]];
			cv::Vec3d curr_v = m_img[pix_id];
			center = center + curr_v;
		}
		center = center * (1.0 / vecIndex.size());
		cv::Vec3d  vc = ch_vertices[j] - center;
		total_loss += cv::norm(vc);
	}

	total_loss /= ch_vertices.size();
	return (m_closs = total_loss);
}

double Frame::GetLoss() {
	double rloss = GetReconstuctLoss();
	double closs = GetCompactLoss();
	double total_loss = SysParameter::FrmRefineRlossWt() * rloss + SysParameter::FrmRefineClossWt()*closs;
	//cout << "rloss: " << rloss << " ,closs = " << closs << " loss = " << loss << endl;
	return total_loss;
}

void Frame::Refine() {
	
	double initial_loss = GetLoss();

	//refine vertex by vertex
	for (int i = 0; i < m_cvxhull.m_vertices.size(); i++) {
		bool ok = RefineSingleVertex(i,m_refine_size);
		if (!ok) {
			RefineSingleVertex(i, m_refine_size / 3.0);
		}
	}
}

//refine single vertex
bool Frame::RefineSingleVertex(int vid, double range) {
	m_curr_refine_vidx = vid;
	cv::Vec3d curr_refine_vert_bak = m_cvxhull.m_vertices[vid];

	cv::Vec3d vertex = m_cvxhull.m_vertices[vid];
	double r = vertex[0];
	double g = vertex[1];
	double b = vertex[2];

	double tol = 1e-4;
	double s = range;
	double lb[3] = { max(r - s,0.0),max(g - s,0.0),max(b - s,0.0) };
	double ub[3] = { min(r + s,1.0),min(g + s,1.0),min(b + s,1.0) };
	double x[3] = { r, g, b };
	double f_min;

	nlopt_opt opter = nlopt_create(NLOPT_LN_COBYLA, 3);
	nlopt_set_lower_bounds(opter, lb);
	nlopt_set_upper_bounds(opter, ub);
	nlopt_add_equality_constraint(opter, constraint,this, tol);
	nlopt_set_min_objective(opter, gloabl_FrmOptimal, this);
	nlopt_set_maxeval(opter,100);
	nlopt_set_xtol_rel(opter, tol);

	nlopt_result result = nlopt_optimize(opter, x, &f_min);
	if (result) {
		//cout << "final loss = " << f_min << ", rloss = " << SysParameter::FrmRefineRlossWt() * m_rloss << ", closs = " << SysParameter::FrmRefineClossWt() *m_closs << " v(" << x[0] << "," << x[1] << "," << x[2] << ")" << endl << endl;
		m_cvxhull.m_vertices[vid] = cv::Vec3d(x[0], x[1], x[2]);

		//if concaver of self intersection，reset	
		vector<cv::Vec3d>& vertices = m_cvxhull.m_vertices;
		try {
			RgbConvexhull new_ch3d(vertices);

			//if concave, reset
			if (new_ch3d.VertsNumberOnConvexHull() != m_cvxhull.m_vertices.size()) {
				m_cvxhull.m_vertices[vid] = curr_refine_vert_bak;
				return false;
			}

			//if self intersection, reset
			else if (m_cvxhull.IsInstersection()) {
				cout << "intersection occured, reset." << endl;
				m_cvxhull.m_vertices[vid] = curr_refine_vert_bak;
				return false;
			}
		}
		catch(QhullError e){
			m_cvxhull.m_vertices[vid] = curr_refine_vert_bak;
			return false;
		}
	}

	nlopt_destroy(opter);
	return true;
}

void Frame::WriteFrame(string path) {
	ofstream of(path);
	for (int i = 0; i < m_cvxhull.m_vertices.size(); i++) {
		cv::Vec3d v = m_cvxhull.m_vertices[i];
		of <<"v "<< v[0] << " " << v[1] << " " << v[2] << endl;
	}

	for (int i = 0; i < m_cvxhull.m_simplices.size(); i++) {
		cv::Vec3i& simplex = m_cvxhull.m_simplices[i];
		of << "f " << simplex[0] + 1 << " " << simplex[1] + 1 << " " << simplex[2] + 1 << endl;
	}
	of.close();
}

double gloabl_FrmOptimal(unsigned n, const double *x, double *grad, void *data) {
	Frame* pfm = (Frame*)data;
	int vid = pfm->m_curr_refine_vidx;
	pfm->m_cvxhull.m_vertices[vid] = cv::Vec3d(x[0], x[1], x[2]);
	double loss = pfm->GetLoss();

	//cout << pfm->m_cvxhull.m_vertices[vid] << "\t" << loss << "，rloss:" << pfm->m_rloss << "closs:" << pfm->m_closs << endl;
	return loss;
}

double constraint(unsigned n, const double *x, double *grad, void *data) {
	Frame* pfm = (Frame*)data;

	for (int i = 0; i < pfm->m_cvxhull.m_vertices.size(); i++)
		if (isnan(pfm->m_cvxhull.m_vertices[i][0]))
			cout << pfm->m_curr_refine_vidx << endl;

	RgbConvexhull new_ch3d;

	vector<cv::Vec3d>& vertices = pfm->m_cvxhull.m_vertices;
	try {
		new_ch3d = RgbConvexhull(vertices);
	}catch (QhullError e) {
		return 1;
	}

	int diff = abs(new_ch3d.m_simplices.size() - pfm->m_cvxhull.m_simplices.size());
	return diff;
}

vector<cv::Vec3d> Frame::GetInsidePixels() {
	vector<cv::Vec3d> out_pixels;
	for (int i = 0; i < m_samp_pix_ids.size(); i++) {
		int pixel_id = m_samp_pix_ids[i];
		Vec3d rgb = m_img[pixel_id];
		if (m_cvxhull.MinDistance2Point(rgb) < 1e-5)
			out_pixels.push_back(rgb);
	}
	return out_pixels;
}